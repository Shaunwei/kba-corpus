#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class OffsetType:
  """
  Offset and OffsetType are used by Annotation to identify the
  portion of a ContentItem that a human labeled with a tag.
  """
  LINES = 1
  BYTES = 2
  CHARS = 3

  _VALUES_TO_NAMES = {
    1: "LINES",
    2: "BYTES",
    3: "CHARS",
  }

  _NAMES_TO_VALUES = {
    "LINES": 1,
    "BYTES": 2,
    "CHARS": 3,
  }


class StreamTime:
  """
  StreamTime is a timestamp measured in seconds since the 1970 epoch.
  epoch_ticks is always in the UTC timezone.  This is used in several
  structs below to record various moments in history.

  Attributes:
   - epoch_ticks
   - zulu_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'epoch_ticks', None, None, ), # 1
    (2, TType.STRING, 'zulu_timestamp', None, None, ), # 2
  )

  def __init__(self, epoch_ticks=None, zulu_timestamp=None,):
    self.epoch_ticks = epoch_ticks
    self.zulu_timestamp = zulu_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.epoch_ticks = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zulu_timestamp = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamTime')
    if self.epoch_ticks is not None:
      oprot.writeFieldBegin('epoch_ticks', TType.DOUBLE, 1)
      oprot.writeDouble(self.epoch_ticks)
      oprot.writeFieldEnd()
    if self.zulu_timestamp is not None:
      oprot.writeFieldBegin('zulu_timestamp', TType.STRING, 2)
      oprot.writeString(self.zulu_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Offset:
  """
  Attributes:
   - type
   - first
   - length
   - xpath
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I32, 'first', None, None, ), # 2
    (3, TType.I32, 'length', None, None, ), # 3
    (4, TType.STRING, 'xpath', None, None, ), # 4
  )

  def __init__(self, type=None, first=None, length=None, xpath=None,):
    self.type = type
    self.first = first
    self.length = length
    self.xpath = xpath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.first = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.length = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.xpath = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Offset')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.first is not None:
      oprot.writeFieldBegin('first', TType.I32, 2)
      oprot.writeI32(self.first)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I32, 3)
      oprot.writeI32(self.length)
      oprot.writeFieldEnd()
    if self.xpath is not None:
      oprot.writeFieldBegin('xpath', TType.STRING, 4)
      oprot.writeString(self.xpath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Label:
  """
  labels are human generated assertions about data.  For example, a
  human author might label their own text by inserting hyperlinks to
  Wikipedia, or a NIST assessor might record judgments about a TREC
  document.

  Attributes:
   - annotator
   - label_time
   - target_kb
   - kb_snapshot_time
   - target_id
   - path
   - offset
   - relevance
   - confidence
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'annotator', None, None, ), # 1
    (2, TType.STRUCT, 'label_time', (StreamTime, StreamTime.thrift_spec), None, ), # 2
    (3, TType.STRING, 'target_kb', None, None, ), # 3
    (4, TType.STRUCT, 'kb_snapshot_time', (StreamTime, StreamTime.thrift_spec), None, ), # 4
    (5, TType.STRING, 'target_id', None, None, ), # 5
    (6, TType.STRING, 'path', None, None, ), # 6
    (7, TType.STRUCT, 'offset', (Offset, Offset.thrift_spec), None, ), # 7
    (8, TType.I16, 'relevance', None, None, ), # 8
    (9, TType.I16, 'confidence', None, None, ), # 9
  )

  def __init__(self, annotator=None, label_time=None, target_kb=None, kb_snapshot_time=None, target_id=None, path=None, offset=None, relevance=None, confidence=None,):
    self.annotator = annotator
    self.label_time = label_time
    self.target_kb = target_kb
    self.kb_snapshot_time = kb_snapshot_time
    self.target_id = target_id
    self.path = path
    self.offset = offset
    self.relevance = relevance
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.annotator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.label_time = StreamTime()
          self.label_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.target_kb = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.kb_snapshot_time = StreamTime()
          self.kb_snapshot_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.target_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.offset = Offset()
          self.offset.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.relevance = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I16:
          self.confidence = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Label')
    if self.annotator is not None:
      oprot.writeFieldBegin('annotator', TType.STRING, 1)
      oprot.writeString(self.annotator)
      oprot.writeFieldEnd()
    if self.label_time is not None:
      oprot.writeFieldBegin('label_time', TType.STRUCT, 2)
      self.label_time.write(oprot)
      oprot.writeFieldEnd()
    if self.target_kb is not None:
      oprot.writeFieldBegin('target_kb', TType.STRING, 3)
      oprot.writeString(self.target_kb)
      oprot.writeFieldEnd()
    if self.kb_snapshot_time is not None:
      oprot.writeFieldBegin('kb_snapshot_time', TType.STRUCT, 4)
      self.kb_snapshot_time.write(oprot)
      oprot.writeFieldEnd()
    if self.target_id is not None:
      oprot.writeFieldBegin('target_id', TType.STRING, 5)
      oprot.writeString(self.target_id)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 6)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.STRUCT, 7)
      self.offset.write(oprot)
      oprot.writeFieldEnd()
    if self.relevance is not None:
      oprot.writeFieldBegin('relevance', TType.I16, 8)
      oprot.writeI16(self.relevance)
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.I16, 9)
      oprot.writeI16(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ContentItem:
  """
  ContentItem contains raw data, an indication of its character
  encoding, and various transformed versions of the raw data.

  'cleansed' is generated from 'raw', and 'ner' is generated from
  'cleansed.'  Generally, 'cleansed' is a tag-stripped version of
  'raw', and 'ner' is the output of a named entity recognizer that
  generates one-word-per-line output.

  For the kba-stream-corpus-2012, the specific tag-stripping and NER
  configurations were:
    'raw' --> boilerpipe 1.2.0 KeepEverything --> 'cleansed'

    'cleansed' -> Stanford CoreNLP ver 1.2.0 with annotators
         {tokenize, cleanxml, ssplit, pos, lemma, ner}, property
         pos.maxlen=100" --> 'ner'

  For the kba-stream-corpus-2013, which includes all the same
  original content as the 2012 corpus plus more, the tag stripping
  and NER configs were:

  cleansed = strip_tags(raw, convert_common_entities=True, space_padding=True)
  which inserts whitespace so that byte offsets into cleansed
  correspond to the same positions in raw.

  ner = wrapper around Stanford CoreNLP v1.3.4 with annotators
         {tokenize, ssplit, pos, lemma, ner, parse, dcoref}


  Attributes:
   - raw
   - encoding
   - cleansed
   - ner
   - labels
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'raw', None, None, ), # 1
    (2, TType.STRING, 'encoding', None, None, ), # 2
    (3, TType.STRING, 'cleansed', None, None, ), # 3
    (4, TType.STRING, 'ner', None, None, ), # 4
    (5, TType.LIST, 'labels', (TType.STRUCT,(Label, Label.thrift_spec)), None, ), # 5
  )

  def __init__(self, raw=None, encoding=None, cleansed=None, ner=None, labels=None,):
    self.raw = raw
    self.encoding = encoding
    self.cleansed = cleansed
    self.ner = ner
    self.labels = labels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.raw = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.encoding = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cleansed = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.labels = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = Label()
            _elem5.read(iprot)
            self.labels.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ContentItem')
    if self.raw is not None:
      oprot.writeFieldBegin('raw', TType.STRING, 1)
      oprot.writeString(self.raw)
      oprot.writeFieldEnd()
    if self.encoding is not None:
      oprot.writeFieldBegin('encoding', TType.STRING, 2)
      oprot.writeString(self.encoding)
      oprot.writeFieldEnd()
    if self.cleansed is not None:
      oprot.writeFieldBegin('cleansed', TType.STRING, 3)
      oprot.writeString(self.cleansed)
      oprot.writeFieldEnd()
    if self.ner is not None:
      oprot.writeFieldBegin('ner', TType.STRING, 4)
      oprot.writeString(self.ner)
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.labels))
      for iter6 in self.labels:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamItem:
  """
  This is the primary interface to the corpus data.  It is called
  StreamItem rather than CorpusItem and has a required StreamTime
  attribute, because even for a static corpus, each document was
  captured at a particular time in Earth history and might have been
  different if captured earlier or later.  All corpora are stream
  corpora, even if they were not explicitly created as such.

  stream_id is the unique identifier for documents in the corpus.


  Attributes:
   - doc_id
   - abs_url
   - schost
   - original_url
   - source
   - body
   - source_metadata
   - stream_id
   - stream_time
   - other_content
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'doc_id', None, None, ), # 1
    (2, TType.STRING, 'abs_url', None, None, ), # 2
    (3, TType.STRING, 'schost', None, None, ), # 3
    (4, TType.STRING, 'original_url', None, None, ), # 4
    (5, TType.STRING, 'source', None, None, ), # 5
    (6, TType.STRUCT, 'body', (ContentItem, ContentItem.thrift_spec), None, ), # 6
    (7, TType.MAP, 'source_metadata', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.STRING, 'stream_id', None, None, ), # 8
    (9, TType.STRUCT, 'stream_time', (StreamTime, StreamTime.thrift_spec), None, ), # 9
    (10, TType.MAP, 'other_content', (TType.STRING,None,TType.STRUCT,(ContentItem, ContentItem.thrift_spec)), None, ), # 10
  )

  def __init__(self, doc_id=None, abs_url=None, schost=None, original_url=None, source=None, body=None, source_metadata=None, stream_id=None, stream_time=None, other_content=None,):
    self.doc_id = doc_id
    self.abs_url = abs_url
    self.schost = schost
    self.original_url = original_url
    self.source = source
    self.body = body
    self.source_metadata = source_metadata
    self.stream_id = stream_id
    self.stream_time = stream_time
    self.other_content = other_content

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.doc_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.abs_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.schost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.original_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.body = ContentItem()
          self.body.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.source_metadata = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = iprot.readString();
            self.source_metadata[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.stream_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.stream_time = StreamTime()
          self.stream_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.other_content = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          for _i18 in xrange(_size14):
            _key19 = iprot.readString();
            _val20 = ContentItem()
            _val20.read(iprot)
            self.other_content[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamItem')
    if self.doc_id is not None:
      oprot.writeFieldBegin('doc_id', TType.STRING, 1)
      oprot.writeString(self.doc_id)
      oprot.writeFieldEnd()
    if self.abs_url is not None:
      oprot.writeFieldBegin('abs_url', TType.STRING, 2)
      oprot.writeString(self.abs_url)
      oprot.writeFieldEnd()
    if self.schost is not None:
      oprot.writeFieldBegin('schost', TType.STRING, 3)
      oprot.writeString(self.schost)
      oprot.writeFieldEnd()
    if self.original_url is not None:
      oprot.writeFieldBegin('original_url', TType.STRING, 4)
      oprot.writeString(self.original_url)
      oprot.writeFieldEnd()
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.STRING, 5)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRUCT, 6)
      self.body.write(oprot)
      oprot.writeFieldEnd()
    if self.source_metadata is not None:
      oprot.writeFieldBegin('source_metadata', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.source_metadata))
      for kiter21,viter22 in self.source_metadata.items():
        oprot.writeString(kiter21)
        oprot.writeString(viter22)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stream_id is not None:
      oprot.writeFieldBegin('stream_id', TType.STRING, 8)
      oprot.writeString(self.stream_id)
      oprot.writeFieldEnd()
    if self.stream_time is not None:
      oprot.writeFieldBegin('stream_time', TType.STRUCT, 9)
      self.stream_time.write(oprot)
      oprot.writeFieldEnd()
    if self.other_content is not None:
      oprot.writeFieldBegin('other_content', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.other_content))
      for kiter23,viter24 in self.other_content.items():
        oprot.writeString(kiter23)
        viter24.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
